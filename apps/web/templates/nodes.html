<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ZETA-SYNC Nodes</title>
    <link rel="stylesheet" href="/static/app.css" />
  </head>
  <body>
    <div class="wrap">
      <header class="top">
        <div>
          <div class="brand">ZETA-SYNC</div>
          <div class="sub">Nodes</div>
        </div>
        <nav class="nav">
          <a href="/">Home</a>
          <a class="active" href="/nodes">Nodes</a>
          <a href="/events">Events</a>
          <a href="/security">Security</a>
        </nav>
      </header>

      <div class="card">
        <div class="row spread">
          <div>
            <h2 style="margin:0">Cluster</h2>
            <div class="muted" id="clusterLine">…</div>
            <div class="small muted" id="clusterRule"></div>
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 8px; justify-content: flex-end;">
            <div class="row" style="gap: 6px; align-items: center; background: #0f141a; border: 1px solid rgba(255,255,255,0.08); padding: 8px 10px; border-radius: 10px;">
              <span class="small muted" style="margin-right: 4px;">History export</span>
              <select id="historyScope" class="input" style="min-width: 150px;">
                <option value="node">This node</option>
                <option value="all">All nodes</option>
                <option value="cluster">Cluster summary</option>
              </select>
              <input id="historyRows" class="input" type="number" min="1" max="50000" value="10000" style="width: 110px;" placeholder="Last N" />
              <button class="btn" onclick="downloadHistory()">Download CSV</button>
            </div>
            <button class="btn" onclick="loadNodes()">Refresh</button>
          </div>
        </div>

        <div id="nodesGrid" class="nodes"></div>

        <details class="adv">
          <summary>Advanced / Debug</summary>
          <pre id="rawNodes"></pre>
        </details>
      </div>
    </div>

    <script src="/static/app.js"></script>
    <script>
      function metric(v){ return (v===null || v===undefined) ? "-" : String(v); }
      function ago(ts){
        if(!ts) return "-";
        const s = Math.max(0, Math.floor(Date.now()/1000 - ts));
        if(s < 10) return "just now";
        if(s < 60) return s + "s ago";
        const m = Math.floor(s/60);
        if(m < 60) return m + "m ago";
        const h = Math.floor(m/60);
        return h + "h ago";
      }

      let localNodeId = null;

      async function loadLocalNodeId(){
        if(localNodeId) return localNodeId;
        const st = await fetch("/api/v1/cluster/status").then(r=>r.json());
        localNodeId = st.node_id || null;
        return localNodeId;
      }

      function syncPill(n){
        const m = n.metrics || {};
        const running = m.sync_running;
        if(running === false || (n.state === "PAUSED")){
          return `<span class="pill paused">SYNC: PAUSED</span>`;
        }
        if(running === true){
          return `<span class="pill active">SYNC: RUNNING</span>`;
        }
        return `<span class="pill unknown">SYNC: ?</span>`;
      }

      function nodeCard(n){
        const m = n.metrics || {};
        const st = n.state || "UNKNOWN";
        const excluded = !!n.excluded;
        const syncOn = !!n.sync_running;

        return `
          <div class="node ${excluded ? "excluded":""}">
            <div class="row spread">
              <div>
                <div class="nodeId">${escapeHtml(n.node_id || "UNKNOWN")}</div>
                <div class="muted">${escapeHtml(n.peer_addr || "-")}</div>
                <div class="small muted">Last seen: ${escapeHtml(ago(n.last_seen))}</div>
              </div>
              <div class="row">
                <div class="pill ${syncOn ? "healthy" : "warning"}">${syncOn ? "SYNC ON" : "SYNC OFF"}</div>
                <div class="pill ${st.toLowerCase()}">${escapeHtml(st)}</div>
              </div>
            </div>

            <div class="kpi">
              <div><span>z</span><b>${metric(m.z)}</b></div>
              <div><span>drift</span><b>${metric(m.drift)}</b></div>
              <div><span>stability</span><b>${metric(m.stability)}</b></div>
              <div><span>ppm</span><b>${metric(m.ppm_offset)}</b></div>
            </div>

            ${excluded ? `<div class="warnBox">Excluded: ${escapeHtml(n.reason || "UNKNOWN")}</div>` : ``}
            ${(!syncOn && (n.online || st === "PAUSED")) ? `<div class="warnBox">Sync paused: metrics will stop updating.</div>` : ``}
          </div>
        `;
      }

      function setBadgeLine(c){
        const line = `Health: ${c.cluster_health || "-"} · Active/Expected: ${c.active_nodes ?? "-"} / ${c.expected_nodes ?? "-"} · Quorum: ${c.quorum || "-"} (need ${c.quorum_needed ?? "-"})`;
        document.getElementById("clusterLine").textContent = line;

        const rule = `HEALTHY when quorum met + no exclusions + stability ≥ ${c.healthy_stability_threshold ?? "-"} for ${c.healthy_required ?? "-"} ticks`;
        document.getElementById("clusterRule").textContent = rule;
      }

      async function loadNodes(){
        const res = await fetch("/api/v1/nodes").then(r=>r.json());
        setBadgeLine(res.cluster || {});
        const nodes = res.nodes || [];
        document.getElementById("nodesGrid").innerHTML = nodes.map(nodeCard).join("");
        document.getElementById("rawNodes").textContent = JSON.stringify(res, null, 2);
      }

      async function downloadHistory(){
        const scope = document.getElementById("historyScope").value;
        const input = document.getElementById("historyRows");
        let n = parseInt(input.value || "", 10);
        if(!n || n < 1) n = 10000;
        if(n > 50000) n = 50000;
        input.value = String(n);

        let url = `/api/v1/export/metrics-history.csv?scope=${encodeURIComponent(scope)}&last_n=${n}`;
        if(scope === "node"){
          const id = await loadLocalNodeId();
          if(id) url += `&node_id=${encodeURIComponent(id)}`;
        }
        window.location = url;
      }

      loadNodes();
      setInterval(loadNodes, 2000);
    </script>
  </body>
</html>
